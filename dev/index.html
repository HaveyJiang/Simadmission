<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Developer Portal</title>
    <link rel="stylesheet" href="styles/style.css" />
</head>
<body>
    <div id="app"></div>

    <script>
        // ==== Supabase keys are NOT used in Dev now (reads go via Vercel) ====
        // Keeping them here wonâ€™t hurt, but theyâ€™re ignored for reads.
        const SUPABASE_URL = 'https://mmpjvhlxqebznermjznl.supabase.co';
        const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1tcGp2aGx4cWViem5lcm1qem5sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MTU5OTMsImV4cCI6MjA3ODQ5MTk5M30.GFmscoJGdD4zwLj4Fn-0hpMFXkdSIYUUo65MdLSfIkM';
        // =======================================================

        // ðŸ”— Your secure Vercel endpoint (serverless function):
        const VERCEL_EVENTS_URL = 'https://simadmission.vercel.app/api/events';

        (function () {

            const app = document.getElementById('app');
            const bc = ('BroadcastChannel' in self) ? new BroadcastChannel('exp-stream') : null;
            const state = { tab: localStorage.getItem('dev_tab') || 'all', expId: localStorage.getItem('dev_expId') || null };

            function load(k, d) { const v = localStorage.getItem(k); return v ? JSON.parse(v) : d; }
            function save(k, v) { localStorage.setItem(k, JSON.stringify(v)); }

            function getExperiments() { return load('experiments', []); }
            function setExperiments(a) { save('experiments', a); }
            function startExperiment(name) {
                const exps = getExperiments();
                const e = { experiment_id: 'E' + Math.floor(Math.random() * 1e6) + '-' + Date.now(), name: name || ('Exp ' + (exps.length + 1)), start_ts: Date.now(), end_ts: null, status: 'active' };
                exps.push(e); setExperiments(exps); render();
            }
            function endExperiment(id) { setExperiments(getExperiments().map(e => e.experiment_id === id ? { ...e, end_ts: Date.now(), status: 'ended' } : e)); render(); }

            // === CHANGED: fetch from Vercel endpoint (secure read) ===
            async function fetchEventsFromDB() {
                try {
                    // Optional paging example: add ?since=<ms>&limit=500
                    const r = await fetch(VERCEL_EVENTS_URL, { cache: 'no-store' });
                    if (!r.ok) {
                        console.warn('Events fetch failed', r.status);
                        return [];
                    }
                    const rows = await r.json();
                    // rows are objects with a top-level mirror + `payload` (the original event)
                    // We normalize to the original payload for downstream logic
                    return Array.isArray(rows) ? rows.map(x => x.payload ?? x) : [];
                } catch (e) {
                    console.error('Events fetch error', e);
                    return [];
                }
            }

            async function getEvents() {
                const fromDb = await fetchEventsFromDB();
                if (fromDb && fromDb.length) return fromDb;
                return load('exp_events', []); // local fallback (rarely used now)
            }

            function experimentsForSession(ts) {
                return getExperiments().filter(e => e.start_ts <= ts && (e.end_ts === null || ts <= e.end_ts));
            }
            function isPendingSession(ts) {
                const exps = getExperiments();
                return !exps.some(e => e.start_ts <= ts && (e.end_ts === null || ts <= e.end_ts));
            }

            function sessionsFromEvents(evs) {
                const by = {};
                for (const ev of evs) {
                    const sid = ev.session_id; if (!sid) continue;
                    if (!by[sid]) by[sid] = { session_id: sid, started_ts: null, finished: false, upload_consent: null, routes: new Set(), channel: null, prolific_id: null };
                    if (ev.name === 'session_meta') { by[sid].channel = ev.channel || by[sid].channel; by[sid].prolific_id = ev.prolific_id || by[sid].prolific_id; }
                    if (ev.name === 'consent_accept') { by[sid].upload_consent = true; if (!by[sid].started_ts) by[sid].started_ts = ev.ts; }
                    if (ev.name === 'consent_decline') { by[sid].upload_consent = false; if (!by[sid].started_ts) by[sid].started_ts = ev.ts; }
                    if (ev.name === 'case_start') { if (!by[sid].started_ts) by[sid].started_ts = ev.ts; by[sid].routes.add(ev.route_code); }
                    if (ev.name === 'session_finish') { by[sid].finished = true; }
                }
                return Object.values(by).map(s => ({ ...s, routes: Array.from(s.routes) })).sort((a, b) => (a.started_ts || 0) - (b.started_ts || 0));
            }

            function rawRows(evs, filterFn) {
                const rows = evs.filter(e => e.name === 'transcript_commit').map(e => ({
                    ts: e.ts,
                    session_id: e.session_id,
                    case_index: e.case_index,
                    within_case_index: e.within_case_index,
                    route_code: e.route_code,
                    transcript_type: e.transcript_type,
                    letters: (e.letters_shown_order || []).join(' '),
                    slider_value: e.slider_value,
                    transcript_time_ms: e.transcript_time_ms
                })).sort((a, b) => a.ts - b.ts);
                if (!filterFn) return rows;
                const sess = sessionsFromEvents(evs).filter(filterFn).map(s => s.session_id);
                const set = new Set(sess);
                return rows.filter(r => set.has(r.session_id));
            }

            function summaryPivot(evs, filterFn, includeTimes) {
                const rows = rawRows(evs, filterFn);
                const types = ['A', 'B']; const codes = [];
                for (const i of types) for (const j of types) for (const k of types) codes.push(i + j + k);
                const cols = [], timeCols = [];
                for (const c of codes) { cols.push(c + '_1', c + '_2', c + '_3'); if (includeTimes) timeCols.push(c + '_1_t', c + '_2_t', c + '_3_t'); }
                const by = {};
                for (const r of rows) {
                    const k = r.session_id;
                    if (!by[k]) by[k] = { session_id: k };
                    const col = r.route_code + '_' + r.within_case_index;
                    by[k][col] = r.slider_value;
                    if (includeTimes) by[k][col + '_t'] = r.transcript_time_ms;
                }
                return { columns: ['session_id', ...cols, ...timeCols], data: Object.values(by) };
            }

            function el(t, a, c) {
                const n = document.createElement(t); a = a || {};
                for (const k in a) { if (k === 'class') n.className = a[k]; else if (k === 'html') n.innerHTML = a[k]; else n.setAttribute(k, a[k]); }
                (c || []).forEach(x => n.appendChild(typeof x === 'string' ? document.createTextNode(x) : x));
                return n;
            }
            function table(hs, rows) {
                const t = el('table'); const thead = el('thead'); const trh = el('tr');
                hs.forEach(h => { const th = el('th', {}, [h]); trh.appendChild(th); });
                thead.appendChild(trh); t.appendChild(thead);
                const tb = el('tbody');
                rows.forEach(r => { const tr = el('tr'); hs.forEach(h => { const td = el('td'); td.textContent = (r[h] !== undefined && r[h] !== null) ? String(r[h]) : ''; tr.appendChild(td); }); tb.appendChild(tr); });
                t.appendChild(tb);
                return t;
            }
            function downloadJSON(filename, obj) {
                const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
                setTimeout(() => URL.revokeObjectURL(a.href), 3000);
            }

            async function render() {
                const evs = await getEvents();
                app.innerHTML = '';
                app.appendChild(el('h1', {}, ['Developer Portal']));

                // Manage experiments
                const manage = el('section'); const row = el('div', { class: 'row' });
                const inp = el('input', { placeholder: 'Experiment name (optional)' });
                const btn = el('button', { class: 'btn primary' }, ['Start Experiment']); btn.onclick = () => startExperiment(inp.value.trim());
                const exportBtn = el('button', { class: 'btn' }, ['Download raw events']); exportBtn.onclick = () => downloadJSON('events.json', evs);
                row.appendChild(inp); row.appendChild(btn); row.appendChild(exportBtn); manage.appendChild(row);

                const chips = el('div', { class: 'row' });
                getExperiments().forEach(e => {
                    const chip = el('div', { class: 'chip' }, [e.name, ' â€” ', new Date(e.start_ts).toLocaleString(), e.end_ts ? ' â†’ ' + new Date(e.end_ts).toLocaleString() : '']);
                    const status = el('span', { class: 'badge ' + (e.status === 'active' ? 'green' : 'gray') }, [e.status.toUpperCase()]);
                    const endB = el('button', { class: 'btn', ...(e.status === 'ended' ? { disabled: true } : {}) }, ['End']); endB.onclick = () => endExperiment(e.experiment_id);
                    chips.appendChild(status); chips.appendChild(chip); chips.appendChild(endB);
                });
                manage.appendChild(chips);
                app.appendChild(manage);

                // Tabs
                const tabs = el('section'); const tabbar = el('div', { class: 'tabbar' });
                const t1 = el('button', { class: 'tab ' + (state.tab === 'exp' ? 'active' : '') }, ['By Experiment']);
                const t2 = el('button', { class: 'tab ' + (state.tab === 'pending' ? 'active' : '') }, ['Pending']);
                const t3 = el('button', { class: 'tab ' + (state.tab === 'all' ? 'active' : '') }, ['All']);
                tabbar.appendChild(t1); tabbar.appendChild(t2); tabbar.appendChild(t3);
                tabs.appendChild(tabbar); const content = el('div', { id: 'tabcontent' }); tabs.appendChild(content); app.appendChild(tabs);

                function draw(which) {
                    state.tab = which; localStorage.setItem('dev_tab', which);
                    t1.classList.toggle('active', which === 'exp'); t2.classList.toggle('active', which === 'pending'); t3.classList.toggle('active', which === 'all');
                    content.innerHTML = '';

                    let filterFn = null;
                    if (which === 'pending') filterFn = s => isPendingSession(s.started_ts || 0);
                    if (which === 'exp') {
                        const exps = getExperiments();
                        const bar = el('div', { class: 'row' });
                        const sel = el('select', {});
                        exps.forEach(e => { const opt = el('option', { value: e.experiment_id }, [e.name]); sel.appendChild(opt); });
                        if (!state.expId && exps.length) state.expId = exps[0].experiment_id;
                        if (state.expId) sel.value = state.expId;
                        bar.appendChild(el('label', {}, ['Experiment: '])); bar.appendChild(sel); content.appendChild(bar);
                        const getFilter = () => (sess => {
                            const exp = exps.find(e => e.experiment_id === sel.value); if (!exp) return false;
                            return (sess.started_ts || 0) >= exp.start_ts && (exp.end_ts === null || (sess.started_ts || 0) <= exp.end_ts);
                        });
                        filterFn = getFilter();
                        sel.onchange = () => { state.expId = sel.value; localStorage.setItem('dev_expId', state.expId); draw('exp'); };
                    }

                    // Sessions
                    const sessSec = el('section'); sessSec.appendChild(el('h2', {}, ['Sessions']));
                    const sessAll = sessionsFromEvents(evs).filter(filterFn || (() => true));
                    const sessRows = sessAll.map(s => ({
                        session_id: s.session_id,
                        started: s.started_ts ? new Date(s.started_ts).toLocaleString() : '',
                        upload_consent: s.upload_consent === null ? '' : (s.upload_consent ? 'true' : 'false'),
                        finished: s.finished ? 'true' : 'false',
                        channel: s.channel || '',
                        prolific_id: s.prolific_id || '',
                        experiments: (s.started_ts ? experimentsForSession(s.started_ts).map(e => e.name).join(', ') : ''),
                        routes: s.routes.join(', ')
                    }));
                    sessSec.appendChild(table(['session_id', 'started', 'upload_consent', 'finished', 'channel', 'prolific_id', 'experiments', 'routes'], sessRows));
                    content.appendChild(sessSec);

                    // Raw
                    const rawSec = el('section'); rawSec.appendChild(el('h2', {}, ['Raw Data']));
                    const rows = rawRows(evs, filterFn);
                    rawSec.appendChild(table(['ts', 'session_id', 'case_index', 'within_case_index', 'route_code', 'transcript_type', 'letters', 'slider_value', 'transcript_time_ms'], rows));
                    content.appendChild(rawSec);

                    // Summary
                    const sumSec = el('section'); const head = el('div', { class: 'row' });
                    head.appendChild(el('h2', {}, ['Summary (reordered)']));
                    const label = el('label', { class: 'row' }, [el('input', { type: 'checkbox', id: 'showtimes' }), ' Show timing columns']);
                    head.appendChild(label); sumSec.appendChild(head); const box = el('div', { id: 'sumBox' }); sumSec.appendChild(box);
                    function drawSummary() {
                        const includeTimes = document.getElementById('showtimes').checked;
                        const sum = summaryPivot(evs, filterFn, includeTimes);
                        box.innerHTML = ''; box.appendChild(table(sum.columns, sum.data));
                    }
                    sumSec.addEventListener('change', e => { if (e.target && e.target.id === 'showtimes') drawSummary(); });
                    drawSummary();
                    content.appendChild(sumSec);
                }

                t1.onclick = () => draw('exp');
                t2.onclick = () => draw('pending');
                t3.onclick = () => draw('all');
                draw(state.tab || 'all');
            }

            // live refresh (3s) and same-device broadcast
            setInterval(() => render(), 3000);
            if (bc) bc.onmessage = () => render();

            render();

        })();
    </script>
</body>
</html>
