<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Developer Portal</title>
    <link rel="stylesheet" href="styles/style.css" />

    <style>
        #update-bar {
            font-size: 0.9rem;
            color: #666;
            margin: 0 0 0.5rem 0;
            display: flex;
            justify-content: flex-end;
        }

        #last-updated {
            font-style: italic;
        }

        body.refreshing #tabcontent {
            opacity: 0.4;
            transition: opacity 0.2s ease;
        }

        body.refreshing #refresh-btn {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        table.exp-table th,
        table.exp-table td {
            white-space: nowrap;
        }

        /* Right-align labels in Finished column for Strays / Total rows */
        .exp-summary-label {
            text-align: right;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
const SUPABASE_URL = 'https://mmpjvhlxqebznermjznl.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1tcGp2aGx4cWViem5lcm1qem5sIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI5MTU5OTMsImV4cCI6MjA3ODQ5MTk5M30.GFmscoJGdD4zwLj4Fn-0hpMFXkdSIYUUo65MdLSfIkM';

const VERCEL_EVENTS_URL = 'https://simadmission.vercel.app/api/events';

(function () {
    const app = document.getElementById('app');
    const bc = ('BroadcastChannel' in self) ? new BroadcastChannel('exp-stream') : null;
    const state = {
        tab: localStorage.getItem('dev_tab') || 'all',
        expId: localStorage.getItem('dev_expId') || null,
        newExpName: ''   // preserve text typed into experiment name box across auto-refresh
    };

    function load(k, d) {
        const v = localStorage.getItem(k);
        return v ? JSON.parse(v) : d;
    }

    function save(k, v) {
        localStorage.setItem(k, JSON.stringify(v));
    }

    function getExperiments() {
        return load('experiments', []);
    }

    function setExperiments(a) {
        save('experiments', a);
    }

    function startExperiment(name) {
        name = name || '';
        name = name.trim();

        // "(Stray)" is reserved for system use
        if (name === '(Stray)') {
            alert('" (Stray) " is a reserved label and cannot be used as an experiment name.');
            return;
        }

        const exps = getExperiments();
        const e = {
            experiment_id: 'E' + Math.floor(Math.random() * 1e6) + '-' + Date.now(),
            name: name || ('Exp ' + (exps.length + 1)),
            start_ts: Date.now(),
            end_ts: null,
            status: 'active'
        };
        exps.push(e);
        setExperiments(exps);
        state.newExpName = ''; // clear the input after starting
        render();
    }

    function endExperiment(id) {
        setExperiments(
            getExperiments().map(e =>
                e.experiment_id === id
                    ? { ...e, end_ts: Date.now(), status: 'ended' }
                    : e
            )
        );
        render();
    }

    async function fetchEventsFromDB() {
        try {
            const r = await fetch(VERCEL_EVENTS_URL, { cache: 'no-store' });
            if (!r.ok) {
                console.warn('Events fetch failed', r.status);
                return [];
            }
            const rows = await r.json();
            return Array.isArray(rows) ? rows.map(x => x.payload ?? x) : [];
        } catch (e) {
            console.error('Events fetch error', e);
            return [];
        }
    }

    async function getEvents() {
        const fromDb = await fetchEventsFromDB();
        if (fromDb && fromDb.length) return fromDb;
        return load('exp_events', []);
    }

    function experimentsForSession(ts) {
        return getExperiments().filter(
            e => e.start_ts <= ts && (e.end_ts === null || ts <= e.end_ts)
        );
    }

    function isPendingSession(ts) {
        const exps = getExperiments();
        return !exps.some(
            e => e.start_ts <= ts && (e.end_ts === null || ts <= e.end_ts)
        );
    }

    function sessionsFromEvents(evs) {
        const by = {};
        for (const ev of evs) {
            const sid = ev.session_id;
            if (!sid) continue;
            if (!by[sid]) {
                by[sid] = {
                    session_id: sid,
                    started_ts: null,
                    finished: false,
                    upload_consent: null,
                    routes: new Set(),
                    channel: null,
                    prolific_id: null
                };
            }
            if (ev.name === 'session_meta') {
                by[sid].channel = ev.channel || by[sid].channel;
                by[sid].prolific_id = ev.prolific_id || by[sid].prolific_id;
            }
            if (ev.name === 'consent_accept') {
                by[sid].upload_consent = true;
                if (!by[sid].started_ts) by[sid].started_ts = ev.ts;
            }
            if (ev.name === 'consent_decline') {
                by[sid].upload_consent = false;
                if (!by[sid].started_ts) by[sid].started_ts = ev.ts;
            }
            if (ev.name === 'case_start') {
                if (!by[sid].started_ts) by[sid].started_ts = ev.ts;
                by[sid].routes.add(ev.route_code);
            }
            if (ev.name === 'session_finish') {
                by[sid].finished = true;
            }
        }
        return Object.values(by)
            .map(s => ({ ...s, routes: Array.from(s.routes) }))
            .sort((a, b) => (a.started_ts || 0) - (b.started_ts || 0));
    }

    function rawRows(evs, filterFn) {
        const rows = evs
            .filter(e => e.name === 'transcript_commit')
            .map(e => ({
                ts: e.ts,
                session_id: e.session_id,
                case_index: e.case_index,
                within_case_index: e.within_case_index,
                route_code: e.route_code,
                transcript_type: e.transcript_type,
                letters: (e.letters_shown_order || []).join(' '),
                slider_value: e.slider_value,
                transcript_time_ms: e.transcript_time_ms
            }))
            .sort((a, b) => a.ts - b.ts);

        if (!filterFn) return rows;

        const sess = sessionsFromEvents(evs)
            .filter(filterFn)
            .map(s => s.session_id);
        const set = new Set(sess);
        return rows.filter(r => set.has(r.session_id));
    }

    // flat rows for pivot-ready CSV
    function flatRows(evs, filterFn) {
        const sessions = sessionsFromEvents(evs);
        const bySid = {};
        sessions.forEach(s => { bySid[s.session_id] = s; });

        const base = rawRows(evs, filterFn);
        return base.map(r => {
            const s = bySid[r.session_id] || {};
            const startedTs = s.started_ts || null;
            const startedLocal = startedTs ? new Date(startedTs).toLocaleString() : '';

            return {
                ts: r.ts,
                ts_local: r.ts ? new Date(r.ts).toLocaleString() : '',
                session_id: r.session_id,
                case_index: r.case_index,
                within_case_index: r.within_case_index,
                route_code: r.route_code,
                transcript_type: r.transcript_type,
                letters: r.letters,
                slider_value: r.slider_value,
                transcript_time_ms: r.transcript_time_ms,
                started_ts: startedTs,
                started_local: startedLocal,
                upload_consent: s.upload_consent === null
                    ? ''
                    : (s.upload_consent ? 'true' : 'false'),
                finished: s.finished ? 'true' : 'false',
                channel: s.channel || '',
                prolific_id: s.prolific_id || '',
                experiments: startedTs
                    ? experimentsForSession(startedTs).map(e => e.name).join(', ')
                    : '',
                session_routes: (s.routes || []).join(', ')
            };
        });
    }

    function summaryPivot(evs, filterFn, includeTimes) {
        const rows = rawRows(evs, filterFn);
        const types = ['A', 'B'];
        const codes = [];
        for (const i of types) {
            for (const j of types) {
                for (const k of types) {
                    codes.push(i + j + k);
                }
            }
        }
        const cols = [];
        const timeCols = [];
        for (const c of codes) {
            cols.push(c + '_1', c + '_2', c + '_3');
            if (includeTimes) timeCols.push(c + '_1_t', c + '_2_t', c + '_3_t');
        }
        const by = {};
        for (const r of rows) {
            const k = r.session_id;
            if (!by[k]) by[k] = { session_id: k };
            const col = r.route_code + '_' + r.within_case_index;
            by[k][col] = r.slider_value;
            if (includeTimes) by[k][col + '_t'] = r.transcript_time_ms;
        }
        return { columns: ['session_id', ...cols, ...timeCols], data: Object.values(by) };
    }

    function el(t, a, c) {
        const n = document.createElement(t);
        a = a || {};
        for (const k in a) {
            if (k === 'class') n.className = a[k];
            else if (k === 'html') n.innerHTML = a[k];
            else n.setAttribute(k, a[k]);
        }
        (c || []).forEach(x =>
            n.appendChild(typeof x === 'string' ? document.createTextNode(x) : x)
        );
        return n;
    }

    function table(hs, rows) {
        const t = el('table');
        const thead = el('thead');
        const trh = el('tr');
        hs.forEach(h => {
            const th = el('th', {}, [h]);
            trh.appendChild(th);
        });
        thead.appendChild(trh);
        t.appendChild(thead);

        const tb = el('tbody');
        rows.forEach(r => {
            const tr = el('tr');
            hs.forEach(h => {
                const td = el('td');
                td.textContent =
                    (r[h] !== undefined && r[h] !== null) ? String(r[h]) : '';
                tr.appendChild(td);
            });
            tb.appendChild(tr);
        });
        t.appendChild(tb);
        return t;
    }

    function downloadJSON(filename, obj) {
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 3000);
    }

    function rowsToCSV(headers, rows) {
        const escapeValue = (v) => {
            if (v === null || v === undefined) return '';
            const s = String(v);
            if (/[",\n]/.test(s)) {
                return '"' + s.replace(/"/g, '""') + '"';
            }
            return s;
        };

        const lines = [];
        lines.push(headers.join(','));
        for (const row of rows) {
            const line = headers.map(h => escapeValue(row[h])).join(',');
            lines.push(line);
        }
        return lines.join('\r\n');
    }

    function downloadCSV(filename, headers, rows) {
        const csv = rowsToCSV(headers, rows);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        setTimeout(() => URL.revokeObjectURL(a.href), 3000);
    }

    // Count sessions per experiment / stray / total, with "finished" info
    function experimentEntryCounts(evs) {
        const exps = getExperiments();
        const sessions = sessionsFromEvents(evs);

        const counts = {}; // expId -> { finished, total }
        exps.forEach(e => {
            counts[e.experiment_id] = { finished: 0, total: 0 };
        });

        let strayFinished = 0;
        let strayTotal = 0;
        let totalFinished = 0;
        const totalTotal = sessions.length;

        sessions.forEach(s => {
            const ts = s.started_ts || null;
            const finished = !!s.finished;
            if (finished) totalFinished++;

            const owned = ts ? experimentsForSession(ts) : [];

            if (!owned.length) {
                // ownerless (Stray)
                strayTotal++;
                if (finished) strayFinished++;
            } else {
                owned.forEach(e => {
                    if (!counts[e.experiment_id]) {
                        counts[e.experiment_id] = { finished: 0, total: 0 };
                    }
                    counts[e.experiment_id].total++;
                    if (finished) counts[e.experiment_id].finished++;
                });
            }
        });

        return {
            counts,        // { expId: { finished, total } }
            strayFinished,
            strayTotal,
            totalFinished,
            totalTotal
        };
    }

    async function render() {
        const evs = await getEvents();
        app.innerHTML = '';

        // Header with refresh button
        const headerRow = el('div', { class: 'row' });
        const title = el('h1', {}, ['Developer Portal']);

        const refreshBtn = el('button', { class: 'btn', id: 'refresh-btn' }, ['Refresh']);
        refreshBtn.onclick = () => {
            document.body.classList.add('refreshing');
            render().finally(() => {
                setTimeout(() => document.body.classList.remove('refreshing'), 150);
            });
        };

        headerRow.appendChild(title);
        headerRow.appendChild(refreshBtn);
        app.appendChild(headerRow);

        const updateBar = el('div', { class: 'row', id: 'update-bar' });
        const updatedLabel = el(
            'span',
            { id: 'last-updated' },
            ['Last updated: ' + new Date().toLocaleString()]
        );
        updateBar.appendChild(updatedLabel);
        app.appendChild(updateBar);

        // ==== Manage experiments ====
        const manage = el('section');

        const controlRow = el('div', { class: 'row' });
        const inp = el('input', { placeholder: 'Experiment name (optional)' });
        inp.value = state.newExpName || '';
        inp.oninput = () => {
            state.newExpName = inp.value;
        };

        const startBtn = el('button', { class: 'btn primary' }, ['Start Experiment']);
        startBtn.onclick = () => startExperiment(inp.value.trim());

        const exportBtn = el('button', { class: 'btn' }, ['Download raw events (JSON)']);
        exportBtn.onclick = () => downloadJSON('events.json', evs);

        controlRow.appendChild(inp);
        controlRow.appendChild(startBtn);
        controlRow.appendChild(exportBtn);
        manage.appendChild(controlRow);

        // Experiments table (with Finished + Entries)
        const exps = getExperiments();
        const entryStats = experimentEntryCounts(evs);
        const counts = entryStats.counts;

        const expTable = el('table', { class: 'exp-table' });
        const expHead = el('thead');
        const expHeadRow = el('tr');

        const expHeaders = [
            'Experiment ID',
            'Name',
            'Status',
            'Start (local)',
            'End (local)',
            'Finished',
            'Entries',
            'Action'
        ];

        expHeaders.forEach(h => {
            expHeadRow.appendChild(el('th', {}, [h]));
        });
        expHead.appendChild(expHeadRow);
        expTable.appendChild(expHead);

        const expBody = el('tbody');

        exps.forEach(e => {
            const stats = counts[e.experiment_id] || { finished: 0, total: 0 };

            const tr = el('tr');
            tr.appendChild(el('td', {}, [e.experiment_id]));
            tr.appendChild(el('td', {}, [e.name]));
            tr.appendChild(el('td', {}, [e.status ? e.status.toUpperCase() : '']));
            tr.appendChild(el('td', {}, [new Date(e.start_ts).toLocaleString()]));
            tr.appendChild(el('td', {}, [e.end_ts ? new Date(e.end_ts).toLocaleString() : '']));
            tr.appendChild(el('td', {}, [String(stats.finished)]));
            tr.appendChild(el('td', {}, [String(stats.total)]));

            const actionTd = el('td');
            if (e.status === 'ended') {
                actionTd.appendChild(el('span', {}, ['—']));
            } else {
                const endBtn = el('button', { class: 'btn' }, ['End']);
                endBtn.onclick = () => endExperiment(e.experiment_id);
                actionTd.appendChild(endBtn);
            }
            tr.appendChild(actionTd);

            expBody.appendChild(tr);
        });

        // Strays row – label bold & right-aligned in Finished column
        const strayTr = el('tr');
        strayTr.appendChild(el('td', {}, ['']));              // Experiment ID
        strayTr.appendChild(el('td', {}, ['']));              // Name
        strayTr.appendChild(el('td', {}, ['']));              // Status
        strayTr.appendChild(el('td', {}, ['']));              // Start
        strayTr.appendChild(el('td', {}, ['']));              // End
        strayTr.appendChild(
            el('td', { class: 'exp-summary-label' }, ['Strays:']) // Finished (label)
        );
        strayTr.appendChild(
            el('td', {}, [String(entryStats.strayTotal)])          // Entries
        );
        strayTr.appendChild(el('td', {}, ['']));              // Action
        expBody.appendChild(strayTr);

        // Total row – same style
        const totalTr = el('tr');
        totalTr.appendChild(el('td', {}, ['']));
        totalTr.appendChild(el('td', {}, ['']));
        totalTr.appendChild(el('td', {}, ['']));
        totalTr.appendChild(el('td', {}, ['']));
        totalTr.appendChild(el('td', {}, ['']));
        totalTr.appendChild(
            el('td', { class: 'exp-summary-label' }, ['Total:'])   // Finished (label)
        );
        totalTr.appendChild(
            el('td', {}, [String(entryStats.totalTotal)])          // Entries
        );
        totalTr.appendChild(el('td', {}, ['']));
        expBody.appendChild(totalTr);

        expTable.appendChild(expBody);
        manage.appendChild(expTable);
        app.appendChild(manage);

        // ==== Tabs ====
        const tabs = el('section');
        const tabbar = el('div', { class: 'tabbar' });
        const t1 = el('button', { class: 'tab ' + (state.tab === 'exp' ? 'active' : '') }, ['By Experiment']);
        const t2 = el('button', { class: 'tab ' + (state.tab === 'pending' ? 'active' : '') }, ['Pending']);
        const t3 = el('button', { class: 'tab ' + (state.tab === 'all' ? 'active' : '') }, ['All']);

        tabbar.appendChild(t1);
        tabbar.appendChild(t2);
        tabbar.appendChild(t3);
        tabs.appendChild(tabbar);

        const content = el('div', { id: 'tabcontent' });
        tabs.appendChild(content);
        app.appendChild(tabs);

        function draw(which) {
            state.tab = which;
            localStorage.setItem('dev_tab', which);
            t1.classList.toggle('active', which === 'exp');
            t2.classList.toggle('active', which === 'pending');
            t3.classList.toggle('active', which === 'all');
            content.innerHTML = '';

            let filterFn = null;
            if (which === 'pending') {
                filterFn = s => isPendingSession(s.started_ts || 0);
            }
            if (which === 'exp') {
                const exps = getExperiments();
                const bar = el('div', { class: 'row' });
                const sel = el('select', {});
                exps.forEach(e => {
                    const opt = el('option', { value: e.experiment_id }, [e.name]);
                    sel.appendChild(opt);
                });
                if (!state.expId && exps.length) state.expId = exps[0].experiment_id;
                if (state.expId) sel.value = state.expId;

                bar.appendChild(el('label', {}, ['Experiment: ']));
                bar.appendChild(sel);
                content.appendChild(bar);

                const getFilter = () => (sess => {
                    const exp = exps.find(e => e.experiment_id === sel.value);
                    if (!exp) return false;
                    return (
                        (sess.started_ts || 0) >= exp.start_ts &&
                        (exp.end_ts === null || (sess.started_ts || 0) <= exp.end_ts)
                    );
                });

                filterFn = getFilter();
                sel.onchange = () => {
                    state.expId = sel.value;
                    localStorage.setItem('dev_expId', state.expId);
                    draw('exp');
                };
            }

            // Sessions
            const sessSec = el('section');
            const sessHeaderRow = el('div', { class: 'row' });
            sessHeaderRow.appendChild(el('h2', {}, ['Sessions']));

            const sessAll = sessionsFromEvents(evs).filter(filterFn || (() => true));
            const sessRows = sessAll.map(s => {
                const expList = s.started_ts
                    ? experimentsForSession(s.started_ts).map(e => e.name)
                    : [];

                let expLabel = '';
                if (!expList.length) {
                    // ownerless session (no experiment covers its start time)
                    expLabel = '(Stray)';
                } else {
                    expLabel = expList.join(', ');
                }

                return {
                    session_id: s.session_id,
                    started: s.started_ts ? new Date(s.started_ts).toLocaleString() : '',
                    upload_consent: s.upload_consent === null
                        ? ''
                        : (s.upload_consent ? 'true' : 'false'),
                    finished: s.finished ? 'true' : 'false',
                    channel: s.channel || '',
                    prolific_id: s.prolific_id || '',
                    experiments: expLabel,
                    routes: s.routes.join(', ')
                };
            });

            const sessHeaders = [
                'session_id',
                'started',
                'upload_consent',
                'finished',
                'channel',
                'prolific_id',
                'experiments',
                'routes'
            ];

            const sessDownloadBtn = el('button', { class: 'btn' }, ['Download CSV']);
            sessDownloadBtn.onclick = () => downloadCSV('sessions.csv', sessHeaders, sessRows);

            sessHeaderRow.appendChild(sessDownloadBtn);
            sessSec.appendChild(sessHeaderRow);
            sessSec.appendChild(table(sessHeaders, sessRows));
            content.appendChild(sessSec);

            // Raw (display) + pivot-ready CSV
            const rawSec = el('section');
            const rawHeaderRow = el('div', { class: 'row' });
            rawHeaderRow.appendChild(el('h2', {}, ['Raw Data']));   // title simplified

            const rawDisplayHeaders = [
                'ts',
                'session_id',
                'case_index',
                'within_case_index',
                'route_code',
                'transcript_type',
                'letters',
                'slider_value',
                'transcript_time_ms'
            ];

            const flat = flatRows(evs, filterFn);
            const flatHeaders = flat.length
                ? Object.keys(flat[0])
                : rawDisplayHeaders;

            const rawDownloadBtn = el('button', { class: 'btn' }, ['Download CSV']);
            rawDownloadBtn.onclick = () => {
                const flatForExport = flatRows(evs, filterFn);
                downloadCSV('raw_long.csv', flatHeaders, flatForExport);
            };

            rawHeaderRow.appendChild(rawDownloadBtn);
            rawSec.appendChild(rawHeaderRow);

            const rawRowsData = rawRows(evs, filterFn);
            rawSec.appendChild(table(rawDisplayHeaders, rawRowsData));
            content.appendChild(rawSec);

            // Summary
            const sumSec = el('section');
            const head = el('div', { class: 'row' });
            head.appendChild(el('h2', {}, ['Summary (reordered)']));

            const label = el('label', { class: 'row' }, [
                el('input', { type: 'checkbox', id: 'showtimes' }),
                ' Show timing columns'
            ]);
            head.appendChild(label);
            sumSec.appendChild(head);

            const box = el('div', { id: 'sumBox' });
            sumSec.appendChild(box);

            function drawSummary() {
                const includeTimes = document.getElementById('showtimes').checked;
                const sum = summaryPivot(evs, filterFn, includeTimes);
                box.innerHTML = '';
                box.appendChild(table(sum.columns, sum.data));
            }

            sumSec.addEventListener('change', e => {
                if (e.target && e.target.id === 'showtimes') drawSummary();
            });
            drawSummary();
            content.appendChild(sumSec);
        }

        t1.onclick = () => draw('exp');
        t2.onclick = () => draw('pending');
        t3.onclick = () => draw('all');
        draw(state.tab || 'all');
    }

    setInterval(() => render(), 3000);
    if (bc) bc.onmessage = () => render();

    render();
})();
    </script>
</body>
</html>
